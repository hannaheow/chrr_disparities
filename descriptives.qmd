---
title: "descriptives"
#format: pdf
execute:
  echo: false      # This hides the code from being printed
  warning: false   # This suppresses warnings
  message: false   # This suppresses messages
  error: false
  results: 'markup' # This ensures that only results are displayed
output:
  html_document: 
  self_contained: true 
---

```{r get data into a usable form }
library(tidyverse)
# Load each file and assign to a new variable name

assign("tract", get(load("calcd_data_how/tract_cis_all_years.RData")))
assign("race", get(load("calcd_data_how/race_cis_all_years.RData")))
assign("income", get(load("calcd_data_how/income_cis_all_years.RData")))
income$year = as.character(income$year)

# Function to rename columns except the first three
rename_columns_cis <- function(df, dataset_name) {
  df %>%
    rename_with(~ ifelse(. %in% c("statecode", "countycode", "fipscode", "GEOID", "year"), ., paste0(dataset_name, "_", .)))
  #, -c(statecode, countycode, fipscode, GEOID))
}

# Rename columns for tract, race, and income
tract <- rename_columns_cis(tract, "tract")
race <- rename_columns_cis(race, "race")
income <- rename_columns_cis(income, "income")

# merge all together
# set all sd_bgv_wt to NA when they are equal to 0 - this is valid because in the calculations step, we consistently use na.rm= TRUE which means that when the 0s occur, this indicates that there were no valid values 
all <- tract %>%
  left_join(race, by = c("statecode", "countycode", "year")) %>%
  left_join(income, by = c("statecode", "countycode", "year")) %>% 
  mutate(race_sd_bgv_wt = ifelse(race_sd_bgv_wt == 0, NA, race_sd_bgv_wt), 
         income_sd_bgv_wt = ifelse(income_sd_bgv_wt == 0, NA, income_sd_bgv_wt),
         tract_sd_bgv_wt = ifelse(tract_sd_bgv_wt == 0, NA, tract_sd_bgv_wt))
all23 = all %>% filter(year == 2023)
```


# median homeownership rates for counties with nonmissing subgroup data 

this needs to be updated to be self contained (ie avoid p drive) later 

```{r}
olddata = haven::read_sas("P:/CH-Ranking/Data/2025/6 Measure Datasets/Additional Measures/v153.sas7bdat")



# Filter the data for different variables where each is not NA
filtered_race <- all23 %>%
  filter(!is.na(race_sd_bgv_wt))

filtered_income <- all23 %>%
  filter(!is.na(income_sd_bgv_wt))


filtered_tract <- all23 %>%
  filter(!is.na(tract_sd_bgv_wt))

# Merge olddata with filtered hist_data by statecode and countycode
merged_race <- olddata %>%
  inner_join(filtered_race, by = c("statecode", "countycode"))

merged_income <- olddata %>%
  inner_join(filtered_income, by = c("statecode", "countycode"))

merged_tract <- olddata %>%
  inner_join(filtered_tract, by = c("statecode", "countycode"))

# Calculate the median of v153_rawvalue for each filtered dataset
median_race <- median(merged_race$v153_rawvalue, na.rm = TRUE)
median_income <- median(merged_income$v153_rawvalue, na.rm = TRUE)
median_tract <- median(merged_tract$v153_rawvalue, na.rm = TRUE)

library(gt)
# Create a table using gt to display the median values
median_table <- tibble(
  Variable = c("v153_rawvalue with race data", "v153_rawvalue with income data", "v153_rawvalue with tract data"),
  Median_Value = c(median_race, median_income, median_tract)
) %>%
  gt() %>%
  tab_header(
    title = "Median Values of v153_rawvalue with available data"
  ) %>% 
  cols_label(
    Variable = "Variable",
    Median_Value = "Median Value"
  ) %>%
  tab_style(
    style = cell_borders(sides = "all", color = "black", weight = px(2)),
    locations = cells_body()
  ) %>%
  tab_options(
    table.width = pct(70),
    column_labels.font.size = 14,
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  )

# Display the table
median_table

```




#explore race subgroup specific homeownership rates 
```{r}

load("~/chrr_disparities/calcd_data_how/race_level.RData")


# Define the race levels with the corresponding labels
race_levels <- c("B", "C", "D", "E", "F", "G", "H", "I")
race_labels <- c("Black", "AIAN", "ASIAN", "NHOPI", "Other", "Two +", "White", "Hispanic")

race_level23 = race_level_all_years %>% filter(year == 2023)

# Boxplot for the race variable with custom labels
ggplot(race_level23, aes(x = factor(race, levels = race_levels), y = rawvalue)) +
  geom_boxplot() +
  scale_x_discrete(labels = race_labels) +  # Set custom x-axis labels
  labs(title = "Rates of homeownership across race/ethnicity subgroups",
       x = "Race/ethnicity subgroup",
       y = "Homeownership rate") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +# Rotate x-axis labels for readability
  theme_minimal() 





```



# Income subgroup homeownership rates 

```{r}
load("~/chrr_disparities/calcd_data_how/income_level.RData")

# Recode the 'grp' variable into income ranges
income_level23 <- income_level_all_years %>%
  filter(year == 2023) %>% 
  mutate(income_group = case_when(
    grp == 1 ~ 'Less than $10,000',
    #grp == 1 ~ '$5,000 to $9,999',
    grp == 2 ~ '$10,000 to $14,999',
    grp == 3 ~ '$15,000 to $24,999',
    #grp == 3 ~ '$20,000 to $24,999',
    grp == 4 ~ '$25,000 to $34,999',
    grp == 5 ~ '$35,000 to $49,999',
    grp == 6 ~ '$50,000 to $74,999',
    grp == 7 ~ '$75,000 to $99,999',
    grp == 8 ~ '$100,000 to $149,999',
    grp == 9 ~ '$150,000 or more'
  ))

# Boxplot for the new 'income_group' variable
ggplot(income_level23, aes(x = factor(income_group, 
                                              levels = c('Less than $10,000', 
                                                         '$10,000 to $14,999', 
                                                         '$15,000 to $24,999', 
                                                         '$25,000 to $34,999', 
                                                         '$35,000 to $49,999', 
                                                         '$50,000 to $74,999', 
                                                         '$75,000 to $99,999', 
                                                         '$100,000 to $149,999', 
                                                         '$150,000 or more')),
                                   y = rawvalue)) +
  geom_boxplot() +
  labs(title = "Rates of homeownership across income groups",
       x = "Income Group",
       y = "Homeownership rate") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotate x-axis labels for readability
```

# tract RUCC code and homeownership rates 
 
```{r}
load("~/chrr_disparities/calcd_data_how/tract_level.RData")

urbcodes = readxl::read_xlsx("inputs/Ruralurbancontinuumcodes2023.xlsx")
urbcodes <- urbcodes %>% mutate(FIPS = as.character(FIPS), # Ensure numeric for join
                                ShortDesc = sub(" -.*", "", Description))  # create metro/nonmetro variable 

tract_level23 = tract_level_all_years %>% filter(year ==2023) %>% 
  left_join(., urbcodes, by = c("fipscode" = "FIPS"))


ggplot(tract_level23, aes(x = as.factor(RUCC_2023), y = rawvalue)) +
  geom_boxplot() +  # Boxplot
  labs(title = "Tract-level rates of homeownership across urbanicity categories",
       x = "RUCC Code where 1 is the most urban and 9 is most rural",  # x-axis label
       y = "Homeownership rate") +  # y-axis label
  theme_minimal() +  # Clean theme for better presentation
  theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Rotate x-axis labels



```


# double check n tract 
```{r only used to verify that the total n used is the total n available}
fips_codes = tidycensus::fips_codes
states <- unique(fips_codes$state)[!unique(fips_codes$state) %in% c("PR", "AS", "GU", "MP", "UM", "VI")]
# (remove DC and PR if you want only 50 states; keep them if you want everything)


all_tracts <- map_df(states, function(st) {
  tidycensus::get_acs(
    geography = "tract",
    variables = "B01001_001",   # total population (any variable works just to fetch GEOIDs)
    state = st,
    geometry = FALSE,           # No geometry -> much faster
    cache_table = TRUE
  ) %>%
    select(GEOID)
})
```


# box-whisker plot with y axis as disparity and x axis is domain 

```{r some set up; actual plot is in next chunk }
library(dplyr)
library(ggplot2)

load("~/chrr_disparities/calcd_data_how/income_cis_all_years.RData")
load("~/chrr_disparities/calcd_data_how/race_cis_all_years.RData")
load("~/chrr_disparities/calcd_data_how/tract_cis_all_years.RData")

# Step 1–3: Filter, select, rename, add domain
income_county <- income %>%
  filter(year == 2023) %>%
  select(statecode, countycode, rawvalue = income_sd_bgv_wt) %>%
  mutate(domain = "Income") %>% filter(rawvalue!=0)

tract_county <- tract %>%
  filter(year == 2023) %>%
  select(statecode, countycode, rawvalue = tract_sd_bgv_wt) %>%
  mutate(domain = "Tract")%>% filter(rawvalue!=0)

race_county <- race %>%
  filter(year == 2023) %>%
  select(statecode, countycode, rawvalue = race_sd_bgv_wt) %>%
  mutate(domain = "Race")%>% filter(rawvalue!=0)

# Step 4: Combine
all_county <- bind_rows(income_county, tract_county, race_county)



```
```{r raincloud plot }
library(ggplot2)
library(ggdist)

ggplot(all_county, aes(x = domain, y = rawvalue, fill = domain, color = domain)) +
  # Half violin (distribution)
  stat_halfeye(
    adjust = 0.5, 
    width = 0.6, 
    .width = 0, 
    alpha = 0.3, 
    justification = -0.3, 
    point_colour = NA
  ) +
  # Boxplot shifted slightly
  geom_boxplot(
    width = 0.15, 
    outlier.shape = NA, 
    alpha = 0.6, 
    position = position_nudge(x = -0.15)
  ) +
  # Optional raw points (the "cloud")
  geom_point(
    alpha = 0.3, 
    size = 1,  
    position = position_jitter(width = 0.2, seed = 123), 
    aes(x = as.numeric(domain) + 0.2)
  ) +
  labs(
    x = "Domain of Disparity",
    y = "Magnitude of Disparity",
    title = "County-Level Disparities (2023)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

library(moments)
stats <- all_county %>%
  group_by(domain) %>%
  summarise(
    N = n(),
    Median = median(rawvalue, na.rm = TRUE),
    SD = sd(rawvalue, na.rm = TRUE),
    Skewness = skewness(rawvalue, na.rm = TRUE),
    Kurtosis = kurtosis(rawvalue, na.rm = TRUE),  # excess kurtosis if you want: kurtosis() - 3
    .groups = "drop"
  ) %>%
  mutate(
    axis_label = paste0(
      domain, 
      "\nN=", N, 
      "\nMed=", round(Median, 2), 
      "\nSD=", round(SD, 2), 
      "\nSkew=", round(Skewness, 2),
      "\nKurt=", round(Kurtosis, 2)
    )
  )

# Build the plot
ggplot(all_county, aes(x = domain, y = rawvalue, fill = domain, color = domain)) +
  stat_halfeye(
    adjust = 0.5, 
    width = 0.6, 
    .width = 0, 
    alpha = 0.3, 
    justification = -0.3, 
    point_colour = NA
  ) +
  geom_boxplot(
    width = 0.15, 
    outlier.shape = NA, 
    alpha = 0.6, 
    position = position_nudge(x = -0.15)
  ) +
  geom_point(
    alpha = 0.3, 
    size = 1,  
    position = position_jitter(width = 0.2, seed = 123), 
    aes(x = as.numeric(domain) + 0.2)
  ) +
  labs(
    x = "",
    y = "Magnitude of Disparity",
    title = "County-Level Disparities"
  ) +
  scale_x_discrete(labels = stats$axis_label) +   # use custom labels
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text = element_text(size = 14),      # axis tick labels
    axis.title = element_text(size = 16),     # axis titles
    plot.title = element_text(size = 18, face = "bold")  # plot title
  )

```



# one table with race, income, and rucc 
```{r}
library(dplyr)

# --- Race summary ---
race_summary <- race_level23 %>%
  group_by(race) %>%
  summarise(
    N = sum(!is.na(rawvalue)),
    median = median(rawvalue, na.rm = TRUE),
    min = min(rawvalue, na.rm = TRUE),
    max = max(rawvalue, na.rm = TRUE),
    sd = sd(rawvalue, na.rm = TRUE)
  ) %>%
  mutate(
    median = round(median, 3),
    sd = round(sd, 3),
    min_max = paste0("(", round(min, 3), ", ", round(max, 3), ")"),
    subgroup_type = "Race/Ethnicity",
    subgroup = recode(race,
                      "B" = "Black", "C" = "AIAN", "D" = "Asian",
                      "E" = "NHOPI", "F" = "Other", "G" = "Two +",
                      "H" = "White", "I" = "Hispanic")
  ) %>%
  select(subgroup_type, subgroup, N, median, min_max, sd)


# --- Income summary ---
income_summary <- income_level23 %>%
  group_by(income_group) %>%
  summarise(
    N = sum(!is.na(rawvalue)),
    median = median(rawvalue, na.rm = TRUE),
    min = min(rawvalue, na.rm = TRUE),
    max = max(rawvalue, na.rm = TRUE),
    sd = sd(rawvalue, na.rm = TRUE)
  ) %>%
  mutate(
    median = round(median, 3),
    sd = round(sd, 3),
    min_max = paste0("(", round(min, 3), ", ", round(max, 3), ")"),
    subgroup_type = "Income",
    subgroup = factor(
      income_group,
      levels = c('Less than $10,000', 
                 '$10,000 to $14,999', 
                 '$15,000 to $24,999', 
                 '$25,000 to $34,999', 
                 '$35,000 to $49,999', 
                 '$50,000 to $74,999', 
                 '$75,000 to $99,999', 
                 '$100,000 to $149,999', 
                 '$150,000 or more')
    )
  ) %>%
  arrange(subgroup) %>%
  select(subgroup_type, subgroup, N, median, min_max, sd)


# --- RUCC summary ---
rucc_summary <- tract_level23 %>%
  group_by(Description) %>%
  summarise(
    N = sum(!is.na(rawvalue)),
    median = median(rawvalue, na.rm = TRUE),
    min = min(rawvalue, na.rm = TRUE),
    max = max(rawvalue, na.rm = TRUE),
    sd = sd(rawvalue, na.rm = TRUE)
  ) %>%
  mutate(
    median = round(median, 3),
    sd = round(sd, 3),
    min_max = paste0("(", round(min, 3), ", ", round(max, 3), ")"),
    subgroup_type = "RUCC",
    subgroup = as.character(Description)
  ) %>%
  #arrange(as.numeric(subgroup)) %>%
  select(subgroup_type, subgroup, N, median, min_max, sd)


# --- Combine all into one table ---
all_subgroup_summary <- bind_rows(race_summary, income_summary, rucc_summary)


# make it pretty

library(gt)

all_subgroup_summary %>%
  gt(rowname_col = "subgroup") %>%
  tab_header(
    title = "Homeownership Rate Summary by Subgroup",
    subtitle = "Median, range, and variation across race/ethnicity, income, and RUCC"
  ) %>%
  cols_label(
    subgroup_type = "Subgroup Type",
    subgroup = "Subgroup",
    N = "N counties with available data",
    median = "Median",
    min_max = "Range (min, max)",
    sd = "Std. Dev."
  ) %>%
  fmt_number(
    columns = c(median, sd),
    decimals = 3
  ) %>%
  tab_options(
    table.border.top.style = "solid",
    table.border.bottom.style = "solid",
    column_labels.font.weight = "bold",
    data_row.padding = px(6)
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "#f9f9f9"),
      cell_borders(sides = "bottom", color = "grey80")
    ),
    locations = cells_body()
  ) %>%
  tab_spanner(
    label = "Homeownership Rates",
    columns = c(median, min_max, sd)
  ) %>%
  opt_table_font(
    font = list(google_font("Lato"), default_fonts())
  )


```



# Median disparities 
Across US counties, the median county-level disparity in homeownership rates across income groups is 

```{r}
median(all23$income_sd_bgv_wt, na.rm = TRUE)

median(all23$tract_sd_bgv_wt, na.rm = TRUE)

median(all23$race_sd_bgv_wt, na.rm = TRUE)


sum(is.na(all$income_sd_bgv_wt))

sum(is.na(all$tract_sd_bgv_wt))

sum(is.na(all$race_sd_bgv_wt)) 


```


There are some differences across urbanicity categories 

```{r disparities by RUCC Category bar plot  }
urbcodes = readxl::read_xlsx("inputs/Ruralurbancontinuumcodes2023.xlsx")
urbcodes <- urbcodes %>% mutate(FIPS = as.numeric(FIPS), # Ensure numeric for join
                                ShortDesc = sub(" -.*", "", Description))  # create metro/nonmetro variable 
all23 = all23 %>% mutate(fipscode = as.numeric(fipscode.x))
all_urb <- left_join(all23, urbcodes, by = c("fipscode" = "FIPS"))

all_urb %>% group_by(RUCC_2023) %>% summarize(median(median(income_sd_bgv_wt, na.rm = TRUE)))
all_urb %>% group_by(RUCC_2023) %>% summarize(median(median(race_sd_bgv_wt, na.rm = TRUE)))
all_urb %>% group_by(RUCC_2023) %>% summarize(median(median(tract_sd_bgv_wt, na.rm = TRUE)))


library(dplyr)
library(tidyr)
library(ggplot2)
library(forcats)

# Summarize the three variables into long format
plot_data <- all_urb %>%
  group_by(Description) %>%
  summarize(
    Income = median(income_sd_bgv_wt, na.rm = TRUE),
    Race   = median(race_sd_bgv_wt, na.rm = TRUE),
    Tract  = median(tract_sd_bgv_wt, na.rm = TRUE)
  ) %>%
  pivot_longer(
    cols = c(Income, Race, Tract),
    names_to = "Measure",
    values_to = "MedianDisparity"
  )

ggplot(plot_data, aes(x = MedianDisparity, y = Description, fill = Measure)) +
  geom_col(position = "dodge") +
  labs(
    title = "Disparities by RUCC Category",
    x = "Median SD of population-weighted group means",
    y = NULL, 
    fill = ""
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "top",
    axis.text.y = element_text(size = 12)
  )

```


# overall correlation 
use pearsons since vals are normally dist and continuous 
```{r}
library(psych)
# Subset the relevant variables
vars <- all_urb[, c("tract_sd_bgv_wt", "income_sd_bgv_wt", "race_sd_bgv_wt")]

# Calculate Pearson's correlations with confidence intervals
corr_results <- corr.test(vars, method = "pearson", adjust = "none", ci = TRUE)

# Print correlation matrix
print(corr_results$r)

# Print conf int 
print(corr_results$ci)



```

# correlations by group 

```{r CORRELATIONS BY URB GROUP}
library(dplyr)
library(tidyr)
library(purrr)

# Select relevant columns and group by RUCC_2023
correlations_by_group <- all_urb %>%
  select(RUCC_2023, income_sd_bgv_wt, race_sd_bgv_wt, tract_sd_bgv_wt) %>%
  group_by(RUCC_2023) %>%
  filter(!is.na(income_sd_bgv_wt) & !is.na(race_sd_bgv_wt) & !is.na(tract_sd_bgv_wt)) %>%
  group_split() %>%
  map_df(function(group_df) {
    cor_matrix <- cor(group_df[, c("income_sd_bgv_wt", "race_sd_bgv_wt", "tract_sd_bgv_wt")], use = "complete.obs")
    
    # Convert correlation matrix to tidy format
    tidy_cor <- as.data.frame(as.table(cor_matrix)) %>%
      filter(Var1 != Var2) %>%
      mutate(RUCC_2023 = unique(group_df$RUCC_2023)) %>%
      select(RUCC_2023, Var1, Var2, Correlation = Freq)
    
    return(tidy_cor)
  })

```


```{r correlations by urb group visualized }

# Define strength levels for coloring
corr_by_group_plot <- correlations_by_group %>%
  filter(Var1 != Var2) %>% #remove self correlations
  mutate(
    strength = case_when(
      abs(Correlation) >= 0.5 ~ "Strong",
      abs(Correlation) >= 0.3 ~ "Moderate",
      TRUE ~ "Weak"
    ),
    strength = factor(strength, levels = c("Strong", "Moderate", "Weak")),  # custom order
    Var1 = recode(Var1,
                  income_sd_bgv_wt = "Income",
                  race_sd_bgv_wt = "Race",
                  tract_sd_bgv_wt = "Tract"),
    Var2 = recode(Var2,
                  income_sd_bgv_wt = "Income",
                  race_sd_bgv_wt = "Race",
                  tract_sd_bgv_wt = "Tract")
  )%>%
  rowwise() %>%
  mutate(pair = paste(sort(c(Var1, Var2)), collapse = "_")) %>%
  ungroup() %>%
  distinct(RUCC_2023, pair, .keep_all = TRUE)

# Plot
ggplot(corr_by_group_plot, aes(x = as.factor(RUCC_2023), y = Correlation, color = strength)) +
  geom_point(size = 3, alpha = 0.8) +
  facet_grid(Var1 ~ Var2, drop = TRUE) +
  scale_color_manual(
    values = c("Strong" = "#E41A1C", "Moderate" = "#377EB8", "Weak" = "#4DAF4A"),
    name = "Correlation Strength"
  ) +
  theme_minimal() +
  labs(
    title = "Correlations between Disparity Domains by RUCC Classification",
    x = "RUCC classification (1 = most urban, 9 = most rural)",
    y = "Correlation of Disparity Domain"
  ) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5),
    strip.text = element_text(face = "bold")
  )





```


### State level correlation 

```{r}
correlations_by_state <- all_urb %>%
  select(statecode, income_sd_bgv_wt, race_sd_bgv_wt, tract_sd_bgv_wt) %>%
  group_by(statecode) %>%
  filter(!is.na(income_sd_bgv_wt) & !is.na(race_sd_bgv_wt) & !is.na(tract_sd_bgv_wt)) %>%
  group_split() %>%
  map_df(function(group_df) {
    cor_matrix <- cor(group_df[, c("income_sd_bgv_wt", "race_sd_bgv_wt", "tract_sd_bgv_wt")], use = "complete.obs")
    
    tidy_cor <- as.data.frame(as.table(cor_matrix)) %>%
      filter(Var1 != Var2) %>%
      mutate(
        statecode = unique(group_df$statecode),
        type = case_when(
          (Var1 == "race_sd_bgv_wt" & Var2 == "income_sd_bgv_wt") | 
            (Var1 == "income_sd_bgv_wt" & Var2 == "race_sd_bgv_wt") ~ "race_income",
          (Var1 == "tract_sd_bgv_wt" & Var2 == "income_sd_bgv_wt") | 
            (Var1 == "income_sd_bgv_wt" & Var2 == "tract_sd_bgv_wt") ~ "tract_income",
          (Var1 == "race_sd_bgv_wt" & Var2 == "tract_sd_bgv_wt") | 
            (Var1 == "tract_sd_bgv_wt" & Var2 == "race_sd_bgv_wt") ~ "race_tract",
          TRUE ~ NA_character_
        )
      ) %>%
      select(statecode, Var1, Var2, Correlation = Freq, type)
    
    return(tidy_cor)
  })


# Prepare for plotting
corr_by_state_plot <- correlations_by_state %>%
  filter(Var1 != Var2) %>%
  mutate(
    strength = case_when(
      abs(Correlation) >= 0.5 ~ "Strong",
      abs(Correlation) >= 0.3 ~ "Moderate",
      TRUE ~ "Weak"
    ),
    strength = factor(strength, levels = c("Strong", "Moderate", "Weak")),
    Var1 = recode(Var1,
                  income_sd_bgv_wt = "Income",
                  race_sd_bgv_wt = "Race",
                  tract_sd_bgv_wt = "Tract"),
    Var2 = recode(Var2,
                  income_sd_bgv_wt = "Income",
                  race_sd_bgv_wt = "Race",
                  tract_sd_bgv_wt = "Tract")
  ) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(Var1, Var2)), collapse = "_")) %>%
  ungroup() %>%
  distinct(statecode, pair, .keep_all = TRUE)


# calculate differences in corr by state (to find states with largest diff across domains)
cor_diff <- correlations_by_state %>%
  # Keep only one row per unique combination of statecode and type (remove duplicates)
  distinct(statecode, type, .keep_all = TRUE) %>%
  # For each state, find min and max correlations, then compute the difference
  group_by(statecode) %>%
  summarize(
    min_cor = min(Correlation, na.rm = TRUE),
    max_cor = max(Correlation, na.rm = TRUE),
    diff_cor = max_cor - min_cor
  ) %>%
  arrange(desc(diff_cor))

# Get top 3 states by pair (highest correlations)
top_states <- corr_by_state_plot %>%
  group_by(type) %>%
  arrange(desc(Correlation)) %>%
  distinct(statecode, .keep_all = TRUE) %>%
  slice_head(n = 3) %>%
  ungroup() %>% 
  pull(statecode)

# Get bottom 3 states by pair (lowest correlations)
bottom_states <- corr_by_state_plot %>%
  group_by(type) %>%
  arrange(Correlation) %>%
  distinct(statecode, .keep_all = TRUE) %>%
  slice_head(n = 3) %>%
  ungroup() %>% 
  pull(statecode)


# Combine them
top_bottom_states <- c(top_states, bottom_states)


# Filter data to include only top and bottom states
corr_top_bottom_filtered <- corr_by_state_plot %>%
  filter(statecode %in% top_bottom_states) %>% 
  arrange(desc(Correlation))

# Create statecode column from urbcodes (left pad first two digits of FIPS)
urb_state_lookup <- urbcodes %>%
  mutate(statecode = substr(str_pad(FIPS, 5, side = "left", pad = "0"), 1,2)) %>%
  distinct(statecode, State)

# Find overlap states (present in both top and bottom sets)
overlap_states <- intersect(top_states, bottom_states)


# Add flag to dataset
corr_top_bottom_with_state <- corr_top_bottom_filtered %>%
  left_join(urb_state_lookup, by = "statecode") %>%
  mutate(
    State = reorder(State, Correlation),
    overlap = ifelse(statecode %in% overlap_states, "overlap", "normal")
  )

# Make a vector of colors for x-axis labels
#axis_colors <- ifelse(levels(corr_top_bottom_with_state$State) %in%                  #corr_top_bottom_with_state$State[corr_top_bottom_with_state$overlap == "overlap"],                      "purple", "black")

# Plot
ggplot(corr_top_bottom_with_state, aes(x = State, y = Correlation, color = strength)) +
  geom_point(size = 3, alpha = 0.8) +
  facet_grid(Var1 ~ Var2, drop = TRUE) +
  scale_color_manual(
    values = c("Strong" = "#E41A1C", "Moderate" = "#377EB8", "Weak" = "#4DAF4A"),
    name = "Correlation Strength"
  ) +
  theme_minimal() +
  labs(
    title = "States with highest and lowest correlations between disparity domains",
    subtitle = "Based on average correlation between Income, Race, and Tract disparity scores",
    x = "State",
    y = "Correlation of Disparity Domains"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),#, colour = axis_colors),
    strip.text = element_text(face = "bold")
  )


```

## State-level correlations between disparity domains (for maps)

```{r state level rho calcs }
library(dplyr)
library(purrr)

# Updated function to safely calculate Spearman's rho
get_spearman_rho <- function(x, y) {
  if (length(na.omit(x)) < 2 || length(na.omit(y)) < 2) {
    return(NA)  # Not enough data to compute correlation
  }
  cor.test(x, y, method = "spearman")$estimate
}

# Calculate Spearman's rho per state
rho_by_state <- hist_data %>%
  group_by(State) %>%
  summarise(
    race_inc_rho = get_spearman_rho(race_sd_bgv_wt, income_sd_bgv_wt),
    tract_inc_rho = get_spearman_rho(tract_sd_bgv_wt, income_sd_bgv_wt),
    tract_race_rho = get_spearman_rho(tract_sd_bgv_wt, race_sd_bgv_wt)
  )

```

```{r state level map function }
library(ggplot2)
library(maps)

# Load US states map
states_map <- map_data("state")

# Convert statecode to lowercase full names (you may need a lookup table here)
# This assumes statecode is a standard two-letter code
library(tibble)

state_lookup <- tibble::tibble(
  State = state.abb,
  statename = tolower(state.name)
)

# Join rho data with full state names
rho_by_state_map <- rho_by_state %>%
  left_join(state_lookup, by = "State") %>%
  filter(!is.na(statename)) # Remove states not matched

```

```{r maps of state level corr between disparities }
# Merge with map data
plot_data <- states_map %>%
  left_join(rho_by_state_map, by = c("region" = "statename"))

# Define a plotting function
plot_rho_map <- function(data, fill_col, title) {
  ggplot(data, aes(x = long, y = lat, group = group, fill = .data[[fill_col]])) +
    geom_polygon(color = "white") +
    coord_fixed(1.3) +
    scale_fill_viridis_c(option = "plasma", na.value = "gray90") +
    labs(title = title, fill = "Spearman's ρ") +
    theme_minimal()
}

# Create each map
map_race_inc <- plot_rho_map(plot_data, "race_inc_rho", "Race vs. Income Correlation by State")
map_tract_inc <- plot_rho_map(plot_data, "tract_inc_rho", "Tract vs. Income Correlation by State")
map_tract_race <- plot_rho_map(plot_data, "tract_race_rho", "Tract vs. Race Correlation by State")

# Display the maps
print(map_race_inc)
print(map_tract_inc)
print(map_tract_race)

library(patchwork)

combined_map <- map_race_inc + map_tract_inc + map_tract_race +
  plot_layout(ncol = 1) +   # change ncol to 1 for vertical
  plot_annotation(
    title = "Correlations Between Disparity Domains",
    subtitle = "Race–Income, Tract–Income, and Race–Tract comparisons"
  )


```





```{r}
# Calculate standard deviation of correlation values per state
state_corr_variability <- corr_by_state_plot %>%
  group_by(statecode) %>%
  summarise(
    sd_corr = sd(Correlation, na.rm = TRUE),
    range_corr = max(Correlation, na.rm = TRUE) - min(Correlation, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(range_corr))  # or arrange(desc(range_corr)) if you prefer range

# View top states with most dissimilar correlations
head(state_corr_variability, 10)

```



###################################################

# Data coverage 

Missingness in rawvalues  


```{r}
# Percent missing – Individuals
pm_indiv_race <- 1 - (race_level23 %>% filter(!is.na(rawvalue)) %>% summarize(sum(pop)) %>% pull()) / sum(race_level23$pop)
pm_indiv_tract <- 1 - (tract_level23 %>% filter(!is.na(rawvalue)) %>% summarize(sum(pop)) %>% pull()) / sum(tract_level23$pop)
pm_indiv_income <- 1 - (income_level23 %>% filter(!is.na(rawvalue)) %>% summarize(sum(num_household)) %>% pull()) / sum(income_level23$num_household)

# Percent missing – Groups
pm_group_race <- 1 - sum(!is.na(race_level23$rawvalue)) / nrow(race_level23)
pm_group_tract <- 1 - sum(!is.na(tract_level23$rawvalue)) / length(unique(tract_level23$GEOID))
pm_group_income <- 1 - sum(!is.na(income_level23$rawvalue)) / nrow(income_level23)

# Create data frame
missing_summary <- data.frame(
  Domain = c("Race/Ethnicity", "Household Income Categories", "Census Tract"),
  pminds = scales::percent(c(pm_indiv_race, pm_indiv_income, pm_indiv_tract), accuracy = 0.1),
  pmgroups = scales::percent(c(pm_group_race, pm_group_income, pm_group_tract ), accuracy = 0.1)
)

# Create gt table
missing_summary %>%
  gt() %>%
  tab_header(
    title = "Summary of Missing Data by Domain",
    subtitle = "Percent missing for individuals (from ACS) and groups (excluded due to unstable estimates)"
  ) %>%
  cols_label(
    Domain = "Domain",
    pminds = "Individuals (%)",
    pmgroups = "Groups (%)"
  ) %>%
  cols_align(
    align = "right",
    columns = c(pminds, pmgroups)
  )# %>%
  #tab_source_note(
  #  source_note = "Note: 'Individuals' refers to people or households with missing ACS data; 'Groups' refers 
  #to categories excluded due to unstable homeownership rate estimates."
  #)

```


Missingness in rawvalues (accounting for zero pop) 


```{r}

race_level23_nozero = race_level23 %>% filter(pop != 0)
tract_level23_nozero = tract_level23 %>% filter(pop != 0)
income_level23_nozero = income_level23 %>% filter(num_household != 0)

# Percent missing – Individuals
pm_indiv_race <- 1 - (race_level23_nozero %>% filter(!is.na(rawvalue)) %>% summarize(sum(pop)) %>% pull()) / sum(race_level23_nozero$pop)
pm_indiv_tract <- 1 - (tract_level23_nozero %>% filter(!is.na(rawvalue)) %>% summarize(sum(pop)) %>% pull()) / sum(tract_level23_nozero$pop)
pm_indiv_income <- 1 - (income_level23_nozero %>% filter(!is.na(rawvalue)) %>% summarize(sum(num_household)) %>% pull()) / sum(income_level23_nozero$num_household)

# Percent missing – Groups
pm_group_race <- 1 - sum(!is.na(race_level23_nozero$rawvalue)) / nrow(race_level23_nozero)
pm_group_tract <- 1 - sum(!is.na(tract_level23_nozero$rawvalue)) / length(unique(tract_level23_nozero$GEOID))
pm_group_income <- 1 - sum(!is.na(income_level23_nozero$rawvalue)) / nrow(income_level23_nozero)

# Create data frame
missing_summary <- data.frame(
  Domain = c("Race/Ethnicity", "Household Income Categories", "Census Tract"),
  pminds = scales::percent(c(pm_indiv_race, pm_indiv_income, pm_indiv_tract), accuracy = 0.1),
  pmgroups = scales::percent(c(pm_group_race, pm_group_income, pm_group_tract ), accuracy = 0.1)
)

# Create gt table
missing_summary %>%
  gt() %>%
  tab_header(
    title = "Summary of Missing Data by Domain",
    subtitle = "Percent missing for individuals (from ACS) and groups (excluded due to unstable estimates)"
  ) %>%
  cols_label(
    Domain = "Domain",
    pminds = "Individuals (%)",
    pmgroups = "Groups (%)"
  ) %>%
  cols_align(
    align = "right",
    columns = c(pminds, pmgroups)
  )# %>%
  #tab_source_note(
  #  source_note = "Note: 'Individuals' refers to people or households with missing ACS data; 'Groups' refers 
  #to categories excluded due to unstable homeownership rate estimates."
  #)

```

# Number of counties with only one tract, race, income  

```{r}
ntract = tract_level23 %>% group_by(statecode, countycode) %>% summarize(ntract = n_distinct(GEOID))

notractdisp = ntract %>% filter(ntract <2) 


nrace = race_level23 %>% group_by(statecode, countycode) %>% 
  #filter(pop!=0) %>% 
  summarize(nrace = n_distinct(race))

nrace_nonzero <- race_level23 %>%
  filter(numerator != 0) %>%
  group_by(statecode, countycode) %>%
  summarize(nrace_nonzero = n_distinct(race), .groups = "drop")

# Identify counties meeting either condition
no_race_disp <- nrace %>%
  left_join(nrace_nonzero, by = c("statecode", "countycode")) %>%
  filter(nrace < 2 | nrace_nonzero < 2)




##########################################
nincome = income_level23 %>% group_by(statecode, countycode) %>% 
  #filter(numerator!=0) %>% 
  summarize(nincome = n_distinct(grp))

nincome_nonzero <- income_level23 %>%
  filter(numerator != 0) %>%
  group_by(statecode, countycode) %>%
  summarize(nincome_nonzero = n_distinct(grp), .groups = "drop")

# Identify counties meeting either condition
no_income_disp <- nincome %>%
  left_join(nincome_nonzero, by = c("statecode", "countycode")) %>%
  filter(nincome < 2 | nincome_nonzero < 2)




```





# Missingness at the county level 
 
```{r}
sum(!is.na(all_urb$race_sd_bgv_wt))/nrow(all23)
sum(!is.na(all_urb$income_sd_bgv_wt))/nrow(all23)
sum(!is.na(all_urb$tract_sd_bgv_wt))/nrow(all23)
```

Across RUCC 
```{r}
# calculate percent missing by RUCC
rucc_miss <- all_urb %>%
  group_by(Description) %>%
  summarise(
    Race    = mean(is.na(race_sd_bgv_wt)),
    Income  = mean(is.na(income_sd_bgv_wt)),
    Tract   = mean(is.na(tract_sd_bgv_wt)),
    .groups = "drop"
  ) %>%
  pivot_longer(cols = c(Race, Income, Tract),
               names_to = "Domain",
               values_to = "PercentMissing") 


# plot with RUCC on y-axis and three bars per RUCC
ggplot(rucc_miss, aes(x = PercentMissing, y = Description, fill = Domain)) +
  geom_col(position = "dodge") +
  scale_x_continuous(labels = scales::percent) +
  labs(
    title = "Missing County-level Disparities by RUCC Category",
    x = "Percent Missing",
    y = "",
   # fill = "Variable"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    axis.text.y = element_text(size = 9)
  )
```

```{r percent missing by state}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)

# Step 1: Calculate percent missing per state
state_miss <- all_urb %>%
  group_by(statecode) %>%
  summarise(
    Race   = mean(is.na(race_sd_bgv_wt)),
    Income = mean(is.na(income_sd_bgv_wt)),
    Tract  = mean(is.na(tract_sd_bgv_wt)),
    .groups = "drop"
  )

# Step 2: Identify top 5 and bottom 5 states by overall missingness
state_miss <- state_miss %>%
  mutate(TotalMissing = Race + Income + Tract)

state_miss_diff <- all_urb %>%
  group_by(statecode) %>%
  summarise(
    Race   = mean(is.na(race_sd_bgv_wt)),
    Income = mean(is.na(income_sd_bgv_wt)),
    Tract  = mean(is.na(tract_sd_bgv_wt)),
    .groups = "drop"
  ) %>%
  mutate(
    max_diff = pmax(Race, Income, Tract) - pmin(Race, Income, Tract)
  ) %>%
  arrange(desc(max_diff))


top_bottom_states <- state_miss_diff %>%
  arrange(desc(max_diff)) %>%
  slice_head(n = 5) %>%
  bind_rows(state_miss %>% arrange(TotalMissing) %>% slice_head(n = 5))

# Optional: Join state names if you have a lookup
state_lookup <- urbcodes %>% 
  mutate(statecode = substr(str_pad(FIPS, 5, side = "left", pad = "0"), 1, 2)) %>%
  distinct(statecode, State)

top_bottom_states <- top_bottom_states %>%
  left_join(state_lookup, by = "statecode")

# Step 3: Pivot longer for ggplot
top_bottom_long <- top_bottom_states %>%
  pivot_longer(cols = c(Race, Income, Tract),
               names_to = "Domain",
               values_to = "PercentMissing")

# Step 4: Plot
ggplot(top_bottom_long, aes(x = PercentMissing, y = reorder(State, PercentMissing), fill = Domain)) +
  geom_col(position = "dodge") +
  scale_x_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    title = "Missing County-level Disparities by State",
    x = "Percent Missing",
    y = "",
    fill = "Domain"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    axis.text.y = element_text(size = 9)
  )

```


# Correlations in missingness 
```{r}

library(psych)

# Step 1: Create missingness indicator matrix (1 = missing, 0 = not missing)
miss_matrix <- is.na(all23[, c("tract_sd_bgv_wt", "race_sd_bgv_wt", "income_sd_bgv_wt")]) * 1

# Step 2: Get correlations with confidence intervals
miss_corr <- corr.test(miss_matrix, method = "pearson", ci = TRUE, adjust = "none")

# View correlation matrix
print(miss_corr$r)

# View confidence intervals
print(miss_corr$ci)  # Or miss_corr$ci.lower and miss_corr$ci.upper

```
# correlations in missingness by RUCC code 

```{r missingness correlation by RUCC classification}
library(dplyr)
library(purrr)
library(psych)

# Variables to check for missingness
vars <- c("tract_sd_bgv_wt", "race_sd_bgv_wt", "income_sd_bgv_wt")

# Loop through groups and compute correlation of missingness
missing_corr_by_group <- all_urb %>%
  select(RUCC_2023, all_of(vars)) %>%
  group_by(RUCC_2023) %>%
  group_split() %>%
  map_df(function(group_df) {
    
    # Get group label
    group_val <- unique(group_df$RUCC_2023)
    
    # Create missingness indicator matrix
    miss_mat <- is.na(group_df[, vars]) * 1
    
    # Skip if not enough rows
    if (nrow(miss_mat) < 3) return(NULL)
    
    # Correlation with confidence intervals
    corr_obj <- corr.test(miss_mat, method = "pearson", ci = TRUE, adjust = "none") 
     # Extract matrices
    r_mat <- corr_obj$r
    lower_mat <- corr_obj$ci.lower
    upper_mat <- corr_obj$ci.upper
    
    # Get unique variable pairs
    pairs <- which(upper.tri(r_mat), arr.ind = TRUE)
    
    # Assemble results
    data.frame(
      RUCC_2023 = group_val,
      Var1 = rownames(r_mat)[pairs[, 1]],
      Var2 = colnames(r_mat)[pairs[, 2]],
      r = round(r_mat[pairs], 3))
     # CI_lower = round(lower_mat[pairs], 3),
    #  CI_upper = round(upper_mat[pairs], 3),
    #  r_ci = paste0(round(r_mat[pairs], 3), 
    #                " (", round(lower_mat[pairs], 3), 
    #                ", ", round(upper_mat[pairs], 3), ")")
    
  })




# Define strength levels for coloring
missing_corr_by_group_plot <- missing_corr_by_group %>%
  filter(Var1 != Var2) %>% #remove self correlations
  mutate(
    strength = case_when(
      abs(r) >= 0.5 ~ "Strong",
      abs(r) >= 0.3 ~ "Moderate",
      TRUE ~ "Weak"
    ),
    strength = factor(strength, levels = c("Strong", "Moderate", "Weak")),  # custom order
    Var1 = recode(Var1,
                  income_sd_bgv_wt = "Income",
                  race_sd_bgv_wt = "Race",
                  tract_sd_bgv_wt = "Tract"),
    Var2 = recode(Var2,
                  income_sd_bgv_wt = "Income",
                  race_sd_bgv_wt = "Race",
                  tract_sd_bgv_wt = "Tract")
  )%>%
  rowwise() %>%
  mutate(pair = paste(sort(c(Var1, Var2)), collapse = "_")) %>%
  ungroup() %>%
  distinct(RUCC_2023, pair, .keep_all = TRUE)

# Plot
ggplot(missing_corr_by_group_plot, aes(x = as.factor(RUCC_2023), y = r, color = strength)) +
  geom_point(size = 3, alpha = 0.8) +
  facet_grid(Var1 ~ Var2, drop = TRUE) +
  scale_color_manual(
    values = c("Strong" = "#E41A1C", "Moderate" = "#377EB8", "Weak" = "#4DAF4A"),
    name = "Correlation Strength"
  ) +
  theme_minimal() +
  labs(
    title = "Missingness Correlation by RUCC Classification",
    x = "RUCC classification (1 = most urban, 9 = most rural)",
    y = "Correlation of Missingness"
  ) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5),
    strip.text = element_text(face = "bold")
  )

```





################################################################################
# SCRATCH 

```{r get the mapping function ready}
library(tigris)
library(ggplot2)
library(dplyr)
library(sf)

# Load county shapefile
#counties <- counties(cb = TRUE, resolution = '20m') %>%  st_as_sf() %>%  rename(statecode = STATEFP, countycode = COUNTYFP) 
#save(counties, file = "inputs/counties_shp.RData")

# Merge data with county shapefile
load("inputs/counties_shp.RData")

map_data <- left_join(counties, all23, by = c("statecode", "countycode"))

# Select columns that contain "sd_bgv_wt" in their name
sd_bgv_wt_columns <- map_data %>% 
  select(contains("sd_bgv_wt")) %>% st_drop_geometry()

# Calculate global minimum and maximum of the selected columns
#global_min <- min(sd_bgv_wt_columns, na.rm = TRUE)
#global_max <- max(sd_bgv_wt_columns, na.rm = TRUE)

# Set specific columns to NA if they are 0
map_data <- map_data %>%
  mutate(across(c(tract_sd_bgv_wt, race_sd_bgv_wt, income_sd_bgv_wt), 
                ~if_else(. == 0, NA_real_, .)))


# Create map plotting function
plot_map <- function(column, title, legend = TRUE) {
  ggplot(map_data) +
    geom_sf(aes_string(fill = column), color = NA) +
    scale_fill_viridis_c(option = "plasma", na.value = "grey80", limits = c(min(map_data[[column]], na.rm = TRUE), max(map_data[[column]], na.rm = TRUE))
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.margin = margin(5, 5, 5, 5),
      panel.grid = element_blank(),
      legend.position = if (legend) "right" else "none"
    ) +
    coord_sf(crs = 5070) +  # Standard Albers Equal Area projection
    labs(fill = title, title = title)
}




```

## Maps with unstable estimates removed

The coasts (California and New England) appear to have high tract and income disparities but possibly lower race disparities. Perhaps we should do some regional and/or state-level exploration.

```{r}
# Plot each map
plot_tract <- plot_map("tract_sd_bgv_wt", "SD across Tracts", legend = FALSE)
plot_income <- plot_map("income_sd_bgv_wt", "SD across Income", legend = FALSE)
plot_race_wlegend <- plot_map("race_sd_bgv_wt", "SD across Race/Ethnicities")

plot_tract
plot_income
plot_race_wlegend
```

## Histograms of SD for Race, Income, Tract

```{r histograms for urb cats}


urbcodes = readxl::read_xlsx("inputs/Ruralurbancontinuumcodes2023.xlsx")
urbcodes <- urbcodes %>% mutate(FIPS = as.numeric(FIPS))  # Ensure numeric for join
all = all23 %>% mutate(fipscode = as.numeric(fipscode.x))
all_urb <- left_join(all, urbcodes, by = c("fipscode" = "FIPS"))


# Set specific columns to NA if they are 0
hist_data <- all_urb %>%
  mutate(across(c(tract_sd_bgv_wt, race_sd_bgv_wt, income_sd_bgv_wt), 
                ~if_else(. == 0, NA_real_, .)))


tworucc = hist_data %>% group_by(RUCC_2023) %>% 
  mutate(RUCC_group = ifelse(RUCC_2023 %in% c(1,2,3), "Urban", "Rural"))


library(grid)
# Create histograms for specified RUCC_2023 code with additional options for cis and BorT
plot_histograms_by_rucc <- function(rucc_group) {
  
  # Filter data for the specified RUCC code
  filtered_data <- tworucc %>% filter(RUCC_group == rucc_group)

 
  # Create histograms for each category
  hist1 <- ggplot(filtered_data, aes(x = race_sd_bgv_wt)) +
    geom_histogram(bins = 30, fill = "#1f77b4", alpha = 0.7) +
    theme_minimal(base_size = 14) + 
    labs(x = "Race", y = "Count")

  hist2 <- ggplot(filtered_data, aes(x = tract_sd_bgv_wt)) +
    geom_histogram(bins = 30, fill = "#ff7f0e", alpha = 0.7) +
    theme_minimal(base_size = 14) +
    labs(x = "Tract", y = "Count")

  hist3 <- ggplot(filtered_data, aes(x = income_sd_bgv_wt)) +
    geom_histogram(bins = 30, fill = "#2ca02c", alpha = 0.7) +
    theme_minimal(base_size = 14) +
    labs(x = "Income", y = "Count")
  
  # Define dynamic title
  main_title <- paste0("SD: ", rucc_group)

  

  # Arrange the plots in a grid with a title
  gridExtra::grid.arrange(
    grobs = list(
      grid::textGrob(main_title, gp = gpar(fontsize = 16, fontface = "bold")),  # Title
      hist1, hist2, hist3
    ))
  
}

plot_histograms_by_rucc(rucc_group = "Rural")
plot_histograms_by_rucc(rucc_group = "Urban")

```

## Correlations

Tract disparities and income disparities are more strongly correlated than tract disparities and race disparities. Income and race disparities are /slightly/ more correlated than tract and race disparities. The correlations below are calculated using Pearson's correlation coefficient and assume Normality and linearity.

```{r correlations}



library(corrplot)
library(ggplot2)
library(pheatmap)

# Assuming the necessary variables are in 'map_data'
# Select the relevant columns for correlation analysis
cor_data <- hist_data %>%
  select(
    tract_cis_sd_bgv_wt, 
    income_cis_sd_bgv_wt, 
    race_cis_sd_bgv_wt, 
  )

# Calculate correlation matrix
cor_matrix <- cor(cor_data, use = "complete.obs", method = "pearson")

# Visualize the correlation matrix using corrplot
corrplot(cor_matrix, method = "color", type = "upper", 
         col = colorRampPalette(c("pink", "white", "lightblue"))(200),
         title = "Correlation Heatmap", 
         mar = c(0,0,1,0))

# Alternatively, you can use pheatmap for a more interactive approach
pheatmap(cor_matrix, 
         display_numbers = TRUE, 
         color = colorRampPalette(c("pink", "white", "lightblue"))(100),
         main = "Correlation Heatmap", 
         fontsize = 12)

```

The strongest correlation occurs between tract and income, weakest between tract and race. All correlations are significant. The correlations below are calculated using Spearman's correlation test which is robust to nonlinear relationships.

```{r}
# Example: Calculate Spearman's correlation
race_inc <- cor.test(hist_data$race_cis_sd_bgv_wt, hist_data$income_cis_sd_bgv_wt, method = "spearman")

tract_inc <- cor.test(hist_data$tract_cis_sd_bgv_wt, hist_data$income_cis_sd_bgv_wt, method = "spearman")

tract_race <- cor.test(hist_data$tract_cis_sd_bgv_wt, hist_data$race_cis_sd_bgv_wt, method = "spearman")

race_inc
tract_inc
tract_race

```



## State-level SD

```{r Calculate the median for each state}

median_by_state <- hist_data %>%
  group_by(State) %>%
  summarise(
    median_tract = median(tract_sd_bgv_wt, na.rm = TRUE),
    median_race = median(race_sd_bgv_wt, na.rm = TRUE),
    median_income = median(income_sd_bgv_wt, na.rm = TRUE),
    .groups = "drop"
  )




# Merge the median values with state names
median_by_state_map <- median_by_state %>%
  left_join(state_lookup, by = "State") %>%
  filter(!is.na(statename))  # Remove unmatched states


```

```{r make the map and print top 3 below}
library(ggplot2)
library(dplyr)

# Merge the state-level median values with the map data
plot_data <- states_map %>%
  left_join(median_by_state_map, by = c("region" = "statename"))

# Function to get the states with the highest median values
get_top_states <- function(data, fill_col, top_n = 3) {
  data %>%
    group_by(region) %>%
    summarise(top_value = max(.data[[fill_col]], na.rm = TRUE)) %>%
    arrange(desc(top_value)) %>%
    head(top_n) %>%
    pull(region)
}

# Function to plot the map and annotate the top states
plot_median_map <- function(data, fill_col, title, top_states) {
  ggplot(data, aes(x = long, y = lat, group = group, fill = .data[[fill_col]])) +
    geom_polygon(color = "white") +
    coord_fixed(1.3) +
    scale_fill_viridis_c(option = "plasma", na.value = "gray90") +
    labs(title = title, fill = "Median Value") +
    theme_minimal() +
    annotate("text", x = -125, y = 25, label = paste("Top States: ", paste(top_states, collapse = ", ")), 
             size = 3, color = "black", hjust = 0, vjust = 0)
}

# Get the top 5 states for each variable
top_states_tract <- get_top_states(plot_data, "median_tract")
top_states_race <- get_top_states(plot_data, "median_race")
top_states_income <- get_top_states(plot_data, "median_income")

# Create the maps for each variable
map_median_tract <- plot_median_map(plot_data, "median_tract", "Median Tract Disparity by State", top_states_tract)
map_median_race <- plot_median_map(plot_data, "median_race", "Median Race Disparity by State", top_states_race)
map_median_income <- plot_median_map(plot_data, "median_income", "Median Income Disparity by State", top_states_income)

# Display the maps
print(map_median_tract)
print(map_median_race)
print(map_median_income)

library(patchwork)
combo_disparitymap = map_median_tract + map_median_race + map_median_income + 
  plot_layout(ncol = 1) + 
  plot_annotation(
    title = "Median disparities by state", 
    subtitle = "Tract, income, race")
combo_disparitymap  

```

## States where tract disparities are greater than income disparities

```{r}
median_by_state %>% filter(median_income < median_tract)



```

## States where race disparities are greater than income disparities

```{r}
median_by_state %>% filter(median_income < median_race)
```

## Missingness

```{r venn diagram}

library(ggvenn)


# Step 2: Create subsets for the Venn diagram based on missing values
venn_data <- list(
  Race = hist_data %>% filter(is.na(race_sd_bgv_wt)) %>% pull(fipscode),
  Tract = hist_data %>% filter(is.na(tract_sd_bgv_wt)) %>% pull(fipscode),
  Income = hist_data %>% filter(is.na(income_sd_bgv_wt)) %>% pull(fipscode)
)

# Calculate total number of missing entries (only consider missing data)
total_missing <- length(unique(c(venn_data$Race, venn_data$Tract, venn_data$Income)))
total_counties = length(unique(hist_data$fipscode.x))

# Step 3: Compute all relevant sets
race_set   <- unique(venn_data$Race)
tract_set  <- unique(venn_data$Tract)
income_set <- unique(venn_data$Income)

# Marginals
pct_race   <- length(race_set)   / total_counties * 100
pct_tract  <- length(tract_set)  / total_counties * 100
pct_income <- length(income_set) / total_counties * 100

# Pairwise overlaps
pct_race_tract   <- length(intersect(race_set, tract_set)) / total_counties * 100
pct_race_income  <- length(intersect(race_set, income_set)) / total_counties * 100
pct_tract_income <- length(intersect(tract_set, income_set)) / total_counties * 100

# Triple overlap
pct_all_three <- length(Reduce(intersect, list(race_set, tract_set, income_set))) / total_counties * 100

# Step 4: Create Venn diagram
ggvenn(
  venn_data,
  show_percentage = FALSE,   # turn off built-in
  fill_color = c("lightblue", "lightgreen", "lightcoral"),
  stroke_color = "black"
) +
  labs(
    title = "Missing Values by Domain",
    subtitle = paste0(
      "Race: ", round(pct_race, 1), "%, ",
      "Tract: ", round(pct_tract, 1), "%, ",
      "Income: ", round(pct_income, 1), "%\n",
      "Race∩Tract: ", round(pct_race_tract, 1), "%, ",
      "Race∩Income: ", round(pct_race_income, 1), "%, ",
      "Tract∩Income: ", round(pct_tract_income, 1), "%\n",
      "All three: ", round(pct_all_three, 1), "%"
    )
  )

```

```{r table of missingness}
# Load the gt package
library(gt)

# Create the missing_counts dataframe
missing_counts <- data.frame(
  category = c("Race", "Tract", "Income"),
  count = c(length(venn_data$race), length(venn_data$tract), length(venn_data$income))
)

# Calculate percent missing for each category
missing_counts$percent_missing <- (missing_counts$count / nrow(hist_data)) * 100

# Use gt to create a simple, pretty table
missing_counts %>%
  gt() %>%
  tab_header(
    title = "Missing Data by Category"
  ) %>%
  cols_label(
    category = "Category",
    count = "Count",
    percent_missing = "Percent Missing"
  ) %>%
  tab_style(
    style = cell_borders(sides = "all", color = "black", weight = px(2)),
    locations = cells_body()
  ) %>%
  tab_options(
    table.width = pct(80),
    column_labels.font.size = 14,
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  )

```

### Summary stats with two RUCC groups

Split is here: <https://www.ers.usda.gov/data-products/rural-urban-continuum-codes/documentation#:~:text=For%20Rural%2DUrban%20Continuum%20Codes,below%20250%2C000%20(code%203).>

```{r latest summary table}



# Load necessary libraries
library(dplyr)
library(gt)

# Assuming 'tworucc' is your dataset, and you have a column named 'RUCC_group'
# Calculate missing and available percentages, along with median, min, max for each variable

tworucc_summary <- tworucc %>%
  mutate(
    # Calculate missing data for each variable
    race_missing = sum(is.na(race_cis_sd_bgv_wt)),
    income_missing = sum(is.na(income_cis_sd_bgv_wt)),
    tract_missing = sum(is.na(tract_cis_sd_bgv_wt)),
    total_count = n(),
    
    # Calculate percent data available
    race_available_percent = (1 - race_missing / total_count) * 100,
    income_available_percent = (1 - income_missing / total_count) * 100,
    tract_available_percent = (1 - tract_missing / total_count) * 100
  ) %>%
  group_by(RUCC_group) %>%
  summarise(
    # Calculate missing counts
    race_missing = sum(is.na(race_cis_sd_bgv_wt)),
    income_missing = sum(is.na(income_cis_sd_bgv_wt)),
    tract_missing = sum(is.na(tract_cis_sd_bgv_wt)),
    
    # Calculate available percentages
    race_available_percent = (1 - race_missing / n()) * 100,
    income_available_percent = (1 - income_missing / n()) * 100,
    tract_available_percent = (1 - tract_missing / n()) * 100,
    
    # Median, min, and max for race, income, and tract (combined)
    race_stats = paste(
      round(median(race_cis_sd_bgv_wt, na.rm = TRUE), 4),
      "(", round(min(race_cis_sd_bgv_wt, na.rm = TRUE), 4),
      ",", round(max(race_cis_sd_bgv_wt, na.rm = TRUE), 4), ")"
    ),
    
    income_stats = paste(
      round(median(income_cis_sd_bgv_wt, na.rm = TRUE), 4),
      "(", round(min(income_cis_sd_bgv_wt, na.rm = TRUE), 4),
      ",", round(max(income_cis_sd_bgv_wt, na.rm = TRUE), 4), ")"
    ),
    
    tract_stats = paste(
      round(median(tract_cis_sd_bgv_wt, na.rm = TRUE), 4),
      "(", round(min(tract_cis_sd_bgv_wt, na.rm = TRUE), 4),
      ",", round(max(tract_cis_sd_bgv_wt, na.rm = TRUE), 4), ")"
    ),
    
    .groups = "drop"
  ) %>%
  bind_rows(
    # Calculate overall summary statistics (combined)
    tibble(
      RUCC_group = "Overall",
      race_missing = sum(is.na(tworucc$race_cis_sd_bgv_wt)),
      income_missing = sum(is.na(tworucc$income_cis_sd_bgv_wt)),
      tract_missing = sum(is.na(tworucc$tract_cis_sd_bgv_wt)),
      
      race_available_percent = (1 - sum(is.na(tworucc$race_cis_sd_bgv_wt)) / nrow(tworucc)) * 100,
      income_available_percent = (1 - sum(is.na(tworucc$income_cis_sd_bgv_wt)) / nrow(tworucc)) * 100,
      tract_available_percent = (1 - sum(is.na(tworucc$tract_cis_sd_bgv_wt)) / nrow(tworucc)) * 100,
      
      race_stats = paste(
        round(median(tworucc$race_cis_sd_bgv_wt, na.rm = TRUE), 4),
        "(", round(min(tworucc$race_cis_sd_bgv_wt, na.rm = TRUE), 4),
        ",", round(max(tworucc$race_cis_sd_bgv_wt, na.rm = TRUE), 4), ")"
      ),
      
      income_stats = paste(
        round(median(tworucc$income_cis_sd_bgv_wt, na.rm = TRUE), 4),
        "(", round(min(tworucc$income_cis_sd_bgv_wt, na.rm = TRUE), 4),
        ",", round(max(tworucc$income_cis_sd_bgv_wt, na.rm = TRUE), 4), ")"
      ),
      
      tract_stats = paste(
        round(median(tworucc$tract_cis_sd_bgv_wt, na.rm = TRUE), 4),
        "(", round(min(tworucc$tract_cis_sd_bgv_wt, na.rm = TRUE), 4),
        ",", round(max(tworucc$tract_cis_sd_bgv_wt, na.rm = TRUE), 4), ")"
      )
    )
  )

# Create the table using gt
tworucc_summary %>%
  gt() %>%
  tab_header(
    title = "Summary of Homeownership Rates by RUCC Group"
  ) %>%
  cols_label(
    RUCC_group = "RUCC Group",
    race_available_percent = "Race Data Available (%)",
    income_available_percent = "Income Data Available (%)",
    tract_available_percent = "Tract Data Available (%)",
    race_stats = "Race (Median, Min, Max)",
    income_stats = "Income (Median, Min, Max)",
    tract_stats = "Tract (Median, Min, Max)"
  ) %>%
  tab_style(
    style = cell_borders(sides = "all", color = "black", weight = px(2)),
    locations = cells_body()
  ) %>%
  tab_options(
    table.width = pct(90),
    column_labels.font.size = 14,
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  ) %>%
  tab_spanner(
    label = "Data Availability",
    columns = vars(race_available_percent, income_available_percent, tract_available_percent)
  ) %>%
  tab_spanner(
    label = "Summary Statistics (Median, Min, Max)",
    columns = vars(race_stats, income_stats, tract_stats)
  )


```

Medians

```{r}
olddata = haven::read_sas("P:/CH-Ranking/Data/2024/6 Measure Datasets/Additional Measures/v153.sas7bdat")



# Filter the data for different variables where each is not NA
filtered_race <- hist_data %>%
  filter(!is.na(race_cis_sd_bgv_wt))

filtered_income <- hist_data %>%
  filter(!is.na(income_cis_sd_bgv_wt))

filtered_tract <- hist_data %>%
  filter(!is.na(tract_cis_sd_bgv_wt))

# Merge olddata with filtered hist_data by statecode and countycode
merged_race <- olddata %>%
  inner_join(filtered_race, by = c("statecode", "countycode"))

merged_income <- olddata %>%
  inner_join(filtered_income, by = c("statecode", "countycode"))

merged_tract <- olddata %>%
  inner_join(filtered_tract, by = c("statecode", "countycode"))

# Calculate the median of v153_rawvalue for each filtered dataset
median_race <- median(merged_race$v153_rawvalue, na.rm = TRUE)
median_income <- median(merged_income$v153_rawvalue, na.rm = TRUE)
median_tract <- median(merged_tract$v153_rawvalue, na.rm = TRUE)

# Create a table using gt to display the median values
median_table <- tibble(
  Variable = c("v153_rawvalue with race data", "v153_rawvalue with income data", "v153_rawvalue with tract data"),
  Median_Value = c(median_race, median_income, median_tract)
) %>%
  gt() %>%
  tab_header(
    title = "Median Values of v153_rawvalue with available data"
  ) %>% 
  cols_label(
    Variable = "Variable",
    Median_Value = "Median Value"
  ) %>%
  tab_style(
    style = cell_borders(sides = "all", color = "black", weight = px(2)),
    locations = cells_body()
  ) %>%
  tab_options(
    table.width = pct(70),
    column_labels.font.size = 14,
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  )

# Display the table
median_table

```
