---
title: "descriptives"
format: html
execute:
  echo: false      # This hides the code from being printed
  warning: false   # This suppresses warnings
  message: false   # This suppresses messages
  error: false
  results: 'markup' # This ensures that only results are displayed
---

```{r get data into a usable form }
library(tidyverse)
# Load each file and assign to a new variable name
assign("tract", get(load("calcd_data_how/tract.RData")))
assign("tract_cis", get(load("calcd_data_how/tract_cis.RData")))
assign("race", get(load("calcd_data_how/race.RData")))
assign("race_cis", get(load("calcd_data_how/race_cis.RData")))
assign("income", get(load("calcd_data_how/income.RData")))
assign("income_cis", get(load("calcd_data_how/income_cis.RData")))

# Function to rename columns except the first three
rename_columns_cis <- function(df, dataset_name) {
  df %>%
    rename_with(~ ifelse(. %in% c("statecode", "countycode", "fipscode", "GEOID"), ., paste0(dataset_name, "_", .)))
  #, -c(statecode, countycode, fipscode, GEOID))
}

# Rename columns for tract_cis, race_cis, and income_cis
tract_cis <- rename_columns_cis(tract_cis, "tract_cis")
race_cis <- rename_columns_cis(race_cis, "race_cis")
income_cis <- rename_columns_cis(income_cis, "income_cis")
tract <- rename_columns_cis(tract, "tract")
race <- rename_columns_cis(race, "race")
income <- rename_columns_cis(income, "income")

# Assuming the objects are named tract, tract_cis, race, race_cis, income, and income_cis
all <- tract %>%
  left_join(tract_cis, by = c("statecode", "countycode")) %>%
  left_join(race, by = c("statecode", "countycode")) %>%
  left_join(race_cis, by = c("statecode", "countycode")) %>%
  left_join(income, by = c("statecode", "countycode")) %>%
  left_join(income_cis, by = c("statecode", "countycode"))

```

## Maps with ALL estimates included 

```{r}
library(tigris)
library(ggplot2)
library(dplyr)
library(sf)

# Load county shapefile
counties <- counties(cb = TRUE, resolution = '20m') %>%
  st_as_sf() %>%
  rename(statecode = STATEFP, 
         countycode = COUNTYFP) 

# Merge data with county shapefile

map_data <- left_join(counties, all, by = c("statecode", "countycode"))

# Select columns that contain "sd_bgv_wt" in their name
sd_bgv_wt_columns <- map_data %>% 
  select(contains("sd_bgv_wt")) %>% st_drop_geometry()

# Calculate global minimum and maximum of the selected columns
#global_min <- min(sd_bgv_wt_columns, na.rm = TRUE)
#global_max <- max(sd_bgv_wt_columns, na.rm = TRUE)

# Set specific columns to NA if they are 0
map_data <- map_data %>%
  mutate(across(c(tract_cis_sd_bgv_wt, race_cis_sd_bgv_wt, income_cis_sd_bgv_wt), 
                ~if_else(. == 0, NA_real_, .)))


# Create map plotting function
plot_map <- function(column, title, legend = TRUE) {
  ggplot(map_data) +
    geom_sf(aes_string(fill = column), color = NA) +
    scale_fill_viridis_c(option = "plasma", na.value = "grey80", limits = c(min(map_data[[column]], na.rm = TRUE), max(map_data[[column]], na.rm = TRUE))
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.margin = margin(5, 5, 5, 5),
      panel.grid = element_blank(),
      legend.position = if (legend) "right" else "none"
    ) +
    coord_sf(crs = 5070) +  # Standard Albers Equal Area projection
    labs(fill = title, title = title)
}


# Plot each map
plot_tract <- plot_map("tract_sd_bgv_wt", "BGV across Tracts", legend = FALSE)
plot_income <- plot_map("income_sd_bgv_wt", "BGV across Income", legend = FALSE)
plot_race_wlegend <- plot_map("race_sd_bgv_wt", "BGV across Race/Ethnicities")

plot_tract
plot_income
plot_race_wlegend

```

## Maps with unstable estimates removed 

Note that BGV is a sum..... so counties without reliable estimates end up with BGV = 0. I manually set BGV = 0 to NA to produce these maps.

The coasts (California and New England) appear to have high tract and income disparities but possibly lower race disparities. Perhaps we should do some regional and/or state-level exploration.

```{r}
# Plot each map
plot_tract <- plot_map("tract_cis_sd_bgv_wt", "BGV across Tracts", legend = FALSE)
plot_income <- plot_map("income_cis_sd_bgv_wt", "BGV across Income", legend = FALSE)
plot_race_wlegend <- plot_map("race_cis_sd_bgv_wt", "BGV across Race/Ethnicities")

plot_tract
plot_income
plot_race_wlegend
```

## Histograms of Race, Income, Tract with and without unstable estimates included 

Note: the number corresponds to the urbanicity category.

1 is the most urban and 9 is the most rural.

BGV values become less meaningful after we remove instable estimates for the most rural (8 and 9) categories.

Across urbanicity categories, the tract domain appears to be most affected by stability. When unstable estimates are removed, the distribution of tract tends to skew right or left; when all estimates are included, the distribution of tract tends Normal.

Note that BGV is a sum.... so counties with unstable estimates end up with BGV values of 0, not NA.

```{r histograms for urb cats}


urbcodes = readxl::read_xlsx("P:/CH-Ranking/Data/2024/9 Results/Rurality medians/Ruralurbancontinuumcodes2023.xlsx")
urbcodes <- urbcodes %>% mutate(FIPS = as.numeric(FIPS))  # Ensure numeric for join
all = all %>% mutate(fipscode = as.numeric(fipscode.x))
all <- left_join(all, urbcodes, by = c("fipscode" = "FIPS"))


# Set specific columns to NA if they are 0
hist_data <- all %>%
  mutate(across(c(tract_cis_sd_bgv_wt, race_cis_sd_bgv_wt, income_cis_sd_bgv_wt), 
                ~if_else(. == 0, NA_real_, .)))


library(grid)
# Create histograms for specified RUCC_2023 code with additional options for cis and BorT
plot_histograms_by_rucc <- function(rucc_code, withcis = FALSE, BorT = "B") {
  
  # Filter data for the specified RUCC code
  filtered_data <- hist_data %>% filter(RUCC_2023 == rucc_code)

  # Define the base variable names based on withcis and BorT
  prefix <- if (withcis) {
    c("tract_cis_", "income_cis_", "race_cis_")
  } else {
    c("tract_", "income_", "race_")
  }
  
  suffix <- if (BorT == "B") {
    "sd_bgv_wt"
  } else if (BorT == "T") {
    "theil_wt"
  }

  # Create histograms for each category
  hist1 <- ggplot(filtered_data, aes_string(x = paste0(prefix[1], suffix))) +
    geom_histogram(bins = 30, fill = "#1f77b4", alpha = 0.7) +
    theme_minimal(base_size = 14) + 
    labs(x = prefix[1], y = "Count")

  hist2 <- ggplot(filtered_data, aes_string(x = paste0(prefix[2], suffix))) +
    geom_histogram(bins = 30, fill = "#ff7f0e", alpha = 0.7) +
    theme_minimal(base_size = 14) +
    labs(x = prefix[2], y = "Count")

  hist3 <- ggplot(filtered_data, aes_string(x = paste0(prefix[3], suffix))) +
    geom_histogram(bins = 30, fill = "#2ca02c", alpha = 0.7) +
    theme_minimal(base_size = 14) +
    labs(x = prefix[3], y = "Count")
  # Define dynamic title
  main_title <- if (BorT == "B") {
    "BGV"
  } else if (BorT == "T") {
    "Theils"
  }

  if (withcis) {
    main_title <- paste(main_title, "\n Only stable estimates included\n", rucc_code)
  } else {
    main_title <- paste(main_title, "\n All estimates included \n", rucc_code)
  }

  # Arrange the plots in a grid with a title
  gridExtra::grid.arrange(
    grobs = list(
      grid::textGrob(main_title, gp = gpar(fontsize = 16, fontface = "bold")),  # Title
      hist1, hist2, hist3
    ))
  
  
  #, 
  #  ncol = 1,
  #  heights = c(0.1, 1)  # Adjust the heights to give space for the title
  #)
}

plot_histograms_by_rucc(rucc_code = 1, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 1, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 2, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 2, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 3, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 3, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 4, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 4, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 5, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 5, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 6, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 6, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 7, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 7, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 7, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 7, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 8, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 8, withcis = FALSE, BorT = "B")

plot_histograms_by_rucc(rucc_code = 9, withcis = TRUE, BorT = "B")
plot_histograms_by_rucc(rucc_code = 9, withcis = FALSE, BorT = "B")


```

## Correlations

Tract disparities and income disparities are more strongly correlated than tract disparities and race disparities. Income and race disparities are /slightly/ more correlated than tract and race disparities.

The strength of the correlation between tract disparities and income disparities is much lower when we include ALL estimates, not just stable ones. This could be because 94.6% of counties that have missing (unstable) values for income estimates also have missing (unstable) values for tract estimates, resulting in artificially high correlation when we use stable estimates only.

#### Stable estimates only 

```{r correlations}



library(corrplot)
library(ggplot2)
library(pheatmap)

# Assuming the necessary variables are in 'map_data'
# Select the relevant columns for correlation analysis
cor_data <- hist_data %>%
  select(
    tract_cis_sd_bgv_wt, 
    income_cis_sd_bgv_wt, 
    race_cis_sd_bgv_wt, 
  )

# Calculate correlation matrix
cor_matrix <- cor(cor_data, use = "complete.obs", method = "pearson")

# Visualize the correlation matrix using corrplot
corrplot(cor_matrix, method = "color", type = "upper", 
         col = colorRampPalette(c("pink", "white", "lightblue"))(200),
         title = "Correlation Heatmap", 
         mar = c(0,0,1,0))

# Alternatively, you can use pheatmap for a more interactive approach
pheatmap(cor_matrix, 
         display_numbers = TRUE, 
         color = colorRampPalette(c("pink", "white", "lightblue"))(100),
         main = "Correlation Heatmap", 
         fontsize = 12)

```

#### ALL data 

```{r}
cor_data <- hist_data %>%
  select(
    tract_sd_bgv_wt, 
    income_sd_bgv_wt, 
    race_sd_bgv_wt, 
  )

# Calculate correlation matrix
cor_matrix <- cor(cor_data, use = "complete.obs", method = "pearson")

# Visualize the correlation matrix using corrplot
corrplot(cor_matrix, method = "color", type = "upper", 
         col = colorRampPalette(c("pink", "white", "lightblue"))(200),
         title = "Correlation Heatmap", 
         mar = c(0,0,1,0))

# Alternatively, you can use pheatmap for a more interactive approach
pheatmap(cor_matrix, 
         display_numbers = TRUE, 
         color = colorRampPalette(c("pink", "white", "lightblue"))(100),
         main = "Correlation Heatmap", 
         fontsize = 12)

```

## Missingness 

```{r venn diagram}

library(ggvenn)


# Step 2: Create subsets for the Venn diagram based on missing values
venn_data <- list(
  race = hist_data %>% filter(is.na(race_cis_sd_bgv_wt)) %>% pull(fipscode),
  tract = hist_data %>% filter(is.na(tract_cis_sd_bgv_wt)) %>% pull(fipscode),
  income = hist_data %>% filter(is.na(income_cis_sd_bgv_wt)) %>% pull(fipscode)
)

# Calculate total number of missing entries (only consider missing data)
total_missing <- length(unique(c(venn_data$race, venn_data$tract, venn_data$income)))



# Create Venn diagram using ggvenn
ggvenn(venn_data, 
       show_percentage = TRUE, 
       fill_color = c("lightblue", "lightgreen", "lightcoral"),
       stroke_color = "black")
      # title = "Venn Diagram of Missing Values for Race, Tract, and Income BGV WT")

```

```{r table of missingness}
# Load the gt package
library(gt)

# Create the missing_counts dataframe
missing_counts <- data.frame(
  category = c("Race", "Tract", "Income"),
  count = c(length(venn_data$race), length(venn_data$tract), length(venn_data$income))
)

# Calculate percent missing for each category
missing_counts$percent_missing <- (missing_counts$count / nrow(hist_data)) * 100

# Use gt to create a simple, pretty table
missing_counts %>%
  gt() %>%
  tab_header(
    title = "Missing Data by Category"
  ) %>%
  cols_label(
    category = "Category",
    count = "Count",
    percent_missing = "Percent Missing"
  ) %>%
  tab_style(
    style = cell_borders(sides = "all", color = "black", weight = px(2)),
    locations = cells_body()
  ) %>%
  tab_options(
    table.width = pct(80),
    column_labels.font.size = 14,
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  )

```

## Descriptive stats by RUCC code 

The largest percent missing occurs for race estimates. The smallest percent missing occurs for tract estimates.

Among very rural counties (9) the percent missing for tract and race disparities is over 13%, but only 8% missing for income disparities.

The magnitude of the median BGV value is highest among urban to suburban (codes 1 through 5) counties across income groups.

The magnitude of the median BGV value is lowest among urban counties (codes 1, 2, 3) across racial groups. Median BGV values are also relatively low for rural (codes 8 and 9) counties across census tracts.

```{r}
# Load necessary libraries
library(dplyr)
library(gt)

# Create the dataset with missing counts, percentages, and summary statistics (median, min, max)
missing_by_rucc <- hist_data %>%
  group_by(RUCC_2023) %>%
  summarise(
    # Missing counts for each variable
    race_missing = sum(is.na(race_cis_sd_bgv_wt)),
    income_missing = sum(is.na(income_cis_sd_bgv_wt)),
    tract_missing = sum(is.na(tract_cis_sd_bgv_wt)),
    
    # Median, min, and max for race, income, and tract
    race_median = round(median(race_cis_sd_bgv_wt, na.rm = TRUE),2),
    race_min = round(min(race_cis_sd_bgv_wt, na.rm = TRUE),2),
    race_max = round(max(race_cis_sd_bgv_wt, na.rm = TRUE),2),
    
    income_median = round(median(income_cis_sd_bgv_wt, na.rm = TRUE),2),
    income_min = round(min(income_cis_sd_bgv_wt, na.rm = TRUE),2),
    income_max = round(max(income_cis_sd_bgv_wt, na.rm = TRUE),2),
    
    tract_median = round(median(tract_cis_sd_bgv_wt, na.rm = TRUE),2),
    tract_min = round(min(tract_cis_sd_bgv_wt, na.rm = TRUE),2),
    tract_max = round(max(tract_cis_sd_bgv_wt, na.rm = TRUE),2),
    
    .groups = "drop"
  ) %>%
  mutate(
    total_count = nrow(venn_data),
    # Calculate the percentage of missing data
    race_percent_missing = (race_missing / nrow(hist_data)) * 100,
    income_percent_missing = (income_missing / nrow(hist_data)) * 100,
    tract_percent_missing = (tract_missing /nrow(hist_data)) * 100,
  # Combine median, min, and max for each variable in the desired format
    race_summary = paste(race_median, "(", race_min, ",", race_max, ")", sep = ""),
    income_summary = paste(income_median, "(", income_min, ",", income_max, ")", sep = ""),
    tract_summary = paste(tract_median, "(", tract_min, ",", tract_max, ")", sep = "")
  ) %>%
  select(
    RUCC_2023,
    # Grouped by Race, Income, Tract
    race_missing, race_percent_missing, race_summary,
    income_missing, income_percent_missing, income_summary,
    tract_missing, tract_percent_missing, tract_summary
  )

# Create the table using gt
missing_by_rucc %>%
  gt() %>%
  tab_header(
    title = "Missing Data and Summary Statistics by RUCC_2023 Category"
  ) %>%
  cols_label(
    RUCC_2023 = "RUCC Code",
    race_missing = "Race Missing Count",
    race_percent_missing = "Race Percent Missing",
    income_missing = "Income Missing Count",
    income_percent_missing = "Income Percent Missing",
    tract_missing = "Tract Missing Count",
    tract_percent_missing = "Tract Percent Missing",
    race_summary = "Race (Median, Min, Max)",
    income_summary = "Income (Median, Min, Max)",
    tract_summary = "Tract (Median, Min, Max)"
  ) %>%
  tab_style(
    style = cell_borders(sides = "all", color = "black", weight = px(2)),
    locations = cells_body()
  ) %>%
  tab_options(
    table.width = pct(90),
    column_labels.font.size = 14,
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  ) %>%
  tab_spanner(
    label = "Missing Counts and Percentages",
    columns = vars(race_missing, race_percent_missing, income_missing, income_percent_missing, tract_missing, tract_percent_missing)
  ) %>%
  tab_spanner(
    label = "Summary Statistics (Median, Min, Max)",
    columns = vars(race_summary, income_summary, tract_summary)
  )
```
